

<!DOCTYPE html>
<html lang="fr">

<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
    <meta name="description" content="">
    <meta name="author" content="">
    <link rel="icon" href="../../../../favicon.ico">

    <title>Directional Shadow Map - OpenGL Avancé</title>

    
    <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/4.0.0-beta.3/css/bootstrap.min.css" integrity="sha384-Zug+QiDoJOrZ5t4lssLdxGhVrurbmBWopoEl+M6BdEfwnCJZtKxi1KgxUyJq13dy" crossorigin="anonymous">

    <style>
        body
        {
          font-family: "Work Sans", "Helvetica", "Tahoma", "Geneva", "Arial", sans-serif;
          color: #444444;
        }

        main
        {
          height:100vh;
          margin-top: 56px;;
        }

        h1, h2, h3, h4, h5, h6
        {
          margin: 2.5rem 0 1.5rem 0;
        }

        h1.section-title
        {
          font-family: "Novacento Sans Wide", "Helvetica", "Tahoma", "Geneva", "Arial", sans-serif;
          text-align: center;
          text-transform: uppercase;
          font-size: 3.25rem;
          margin: 1.0rem 0 1.5rem 0;
          font-weight: 200;
        }

        main a:hover
        {
          text-decoration: none;
        }

        main table
        {
          width: 100%;
          margin-bottom: 1rem;
        }

        main img
        {
          width: 100%;
        }

        .jumbotron
        {
          background-color: #EEEEEE;
        }

        .page-content
        {
          padding-top: 16px;
          padding-bottom: 1.5rem;
        }

        .main-article
        {
          margin-left: 15%;
          margin-right: 15%;
        }

        .middle-content
        {
          text-align: justify;
        }

        .side-menu
        {
          background-color: #EEEEEE;
          position: fixed;
          width: 15%;
          height: 100%;
          font-size: 1.0em;
          padding-left: 0px;
          padding-right: 0px;
        }

        .side-menu li li
        {
          font-size: 0.9em;
          width: 100%;
        }

        .side-menu a
        {
          color: #555555;
          font-weight: bold;
        }

        .side-menu a:hover
        {
          color: #CCCCCC;
          background-color: #343A40;
        }

        .side-menu-left
        {
          left: 0px;
        }

        .side-menu-right
        {
          right: 0px;
        }

        .highlight
        {
          margin-bottom: 1rem;
        }

        .highlight pre
        {
          margin: auto;
          padding: 1% 5% 1% 5%;
        }
    </style>
</head>

<body>

<nav class="navbar navbar-expand-md navbar-dark fixed-top bg-dark">
  <a class="navbar-brand" href="https://Celeborn2BeAlive.github.io/opengl-avance/">OpenGL Avancé</a>
  <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarsExampleDefault" aria-controls="navbarsExampleDefault" aria-expanded="false" aria-label="Toggle navigation">
    <span class="navbar-toggler-icon"></span>
  </button>

  <div class="collapse navbar-collapse" id="navbarsExampleDefault">
    <ul class="navbar-nav mr-auto">
        
            <li class="nav-item">
                <a class="nav-link" href="https://Celeborn2BeAlive.github.io/opengl-avance/01-introduction/introduction">Introduction</a>
            </li>
        
            <li class="nav-item">
                <a class="nav-link" href="https://Celeborn2BeAlive.github.io/opengl-avance/02-forward-renderer/pipeline">Forward Renderer</a>
            </li>
        
            <li class="nav-item">
                <a class="nav-link" href="https://Celeborn2BeAlive.github.io/opengl-avance/03-deferred-renderer/pipeline">Deferred Renderer</a>
            </li>
        
            <li class="nav-item active">
                <a class="nav-link" href="https://Celeborn2BeAlive.github.io/opengl-avance/04-shadow-mapping/introduction">Shadow Mapping</a>
            </li>
        
            <li class="nav-item">
                <a class="nav-link" href="https://Celeborn2BeAlive.github.io/opengl-avance/05-post-processing/introduction">Post Processing</a>
            </li>
        
            <li class="nav-item">
                <a class="nav-link" href="https://Celeborn2BeAlive.github.io/opengl-avance/06-course/opengl-context">Cours et Doc</a>
            </li>
        



      
    </ul>
  </div>
</nav>

<main role="main" class="main-article">

<div class="container-fluid">
    <div class="row">
        <div class="col side-menu side-menu-left page-content">
            <ul class="nav flex-column">
    
        <li class="nav-item">
            <a class="nav-link" href="https://Celeborn2BeAlive.github.io/opengl-avance/04-shadow-mapping/introduction/">Introduction</a>
        </li>
    
        <li class="nav-item">
            <a class="nav-link" href="https://Celeborn2BeAlive.github.io/opengl-avance/04-shadow-mapping/dir-shadow-map/">Directional Shadow Map</a>
        </li>
    
        <li class="nav-item">
            <a class="nav-link" href="https://Celeborn2BeAlive.github.io/opengl-avance/04-shadow-mapping/percentage-closest-filtering/">Percentage Closest Filtering</a>
        </li>
    
        <li class="nav-item">
            <a class="nav-link" href="https://Celeborn2BeAlive.github.io/opengl-avance/04-shadow-mapping/aller-plus-loin/">Aller plus loin</a>
        </li>
    
</ul>
        </div>

        <div class="col middle-content page-content">
            <h1 class="section-title">Directional Shadow Map</h1>

            

<p>Nous allons commencer par l&rsquo;utilisation du shadow mapping pour une lumière directionnelle, qui est plus simple.</p>

<p>Il y a globalement quatre partie à coder:</p>

<ul>
<li>Initialisation: Allocation des données OpenGL nécessaire à l&rsquo;algorithme</li>
<li>Shaders: Coder les shaders nécessaire à la création de la shadow map.</li>
<li>Création de la shadow map: A faire au rendu des que la direction de la lumière est modifiée. Il s&rsquo;agit de calculer la depth map selon le point de vue de la light.</li>
<li>Utilisation de la shadow map: A faire dans la shading pass. Il s&rsquo;agit avant d&rsquo;éclairer un fragment vu par la caméra de vérifier s&rsquo;il est visible depuis la light en utilisant la depth map précalculée.</li>
</ul>

<h1 id="initialisation">Initialisation</h1>

<p>Dans la classe Application, ajoutez 4 variables:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="">GLuint</span><span style=""> </span><span style="">m_directionalSMTexture</span><span style="">;</span><span style="">
</span><span style=""></span><span style="">GLuint</span><span style=""> </span><span style="">m_directionalSMFBO</span><span style="">;</span><span style="">
</span><span style=""></span><span style="">GLuint</span><span style=""> </span><span style="">m_directionalSMSampler</span><span style="">;</span><span style="">
</span><span style=""></span><span style="">int32_t</span><span style=""> </span><span style="">m_nDirectionalSMResolution</span><span style=""> </span><span style="color:#f92672">=</span><span style=""> </span><span style="color:#ae81ff">512</span><span style="">;</span></code></pre>
</div>
<p>La première est destinée à stocker un identifiant de texture OpenGL qui contiendra la depth map selon le point de vue de la light.</p>

<p>La deuxième est destinée à stocker un identifiant de framebuffer OpenGL qui nous permettra de dessiner la depth map.</p>

<p>La troisème est destinée à stocker un identifiant de sampler OpenGL qui nous permettra de lire la depth map depuis un shader.</p>

<p>Enfin la dernière stocke simplement la résolution de la depth map (ici 512x512).</p>

<p>Dans le constructeur de l&rsquo;application, créez à la texture m_directionalSMTexture, de target GL_TEXTURE_2D et de format interne GL_DEPTH_COMPONENT32F.</p>

<p>Créez le framebuffer m_directionalSMFBO et attachez lui la texture m_directionalSMTexture sur l&rsquo;attachment GL_DEPTH_ATTACHMENT (voir le code de l&rsquo;initialisation du GBuffer du deferred shading pour exemple).</p>

<p>Vérifiez la validité du framebuffer, puis débindez le framebuffer.</p>

<p>Créez enfin le sampler m_directionalSMSampler avec le code suivant:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="">glGenSamplers</span><span style="">(</span><span style="color:#ae81ff">1</span><span style="">,</span><span style=""> </span><span style="color:#f92672">&amp;</span><span style="">m_directionalSMSampler</span><span style="">);</span><span style="">
</span><span style=""></span><span style="">glSamplerParameteri</span><span style="">(</span><span style="">m_directionalSMSampler</span><span style="">,</span><span style=""> </span><span style="">GL_TEXTURE_MIN_FILTER</span><span style="">,</span><span style=""> </span><span style="">GL_LINEAR</span><span style="">);</span><span style="">
</span><span style=""></span><span style="">glSamplerParameteri</span><span style="">(</span><span style="">m_directionalSMSampler</span><span style="">,</span><span style=""> </span><span style="">GL_TEXTURE_MAG_FILTER</span><span style="">,</span><span style=""> </span><span style="">GL_LINEAR</span><span style="">);</span><span style="">
</span><span style=""></span><span style="">glSamplerParameteri</span><span style="">(</span><span style="">m_directionalSMSampler</span><span style="">,</span><span style=""> </span><span style="">GL_TEXTURE_WRAP_S</span><span style="">,</span><span style=""> </span><span style="">GL_CLAMP_TO_BORDER</span><span style="">);</span><span style="">
</span><span style=""></span><span style="">glSamplerParameteri</span><span style="">(</span><span style="">m_directionalSMSampler</span><span style="">,</span><span style=""> </span><span style="">GL_TEXTURE_WRAP_T</span><span style="">,</span><span style=""> </span><span style="">GL_CLAMP_TO_BORDER</span><span style="">);</span></code></pre>
</div>
<p>Fonctions GL à utiliser:</p>

<table>
<thead>
<tr>
<th>Sans DSA</th>
<th>DSA</th>
</tr>
</thead>

<tbody>
<tr>
<td>glGenTextures</td>
<td>glCreateTextures</td>
</tr>

<tr>
<td>glBindTexture</td>
<td></td>
</tr>

<tr>
<td>glTexStorage2D</td>
<td>glTextureStorage2D</td>
</tr>

<tr>
<td>glGenFramebuffers</td>
<td>glCreateFramebuffers</td>
</tr>

<tr>
<td>glBindFramebuffer(GL_DRAW_FRAMEBUFFER, fbo)</td>
<td></td>
</tr>

<tr>
<td>glFramebufferTexture2D</td>
<td>glNamedFramebufferTexture</td>
</tr>

<tr>
<td>glDrawBuffers</td>
<td>glNamedFramebufferDrawBuffers</td>
</tr>

<tr>
<td>glCheckFramebufferStatus</td>
<td>glCheckNamedFramebufferStatus</td>
</tr>

<tr>
<td>glGenSamplers</td>
<td>glCreateSamplers</td>
</tr>

<tr>
<td>glSamplerParameteri</td>
<td>glSamplerParameteri</td>
</tr>
</tbody>
</table>

<h1 id="shaders">Shaders</h1>

<p>Ajoutez deux nouveaux shaders <em>directionalSM.vs.glsl</em> et <em>directionalSM.fs.glsl</em>.</p>

<p>L&rsquo;objectif du vertex shader est de transformer le sommet d&rsquo;entrée dans l&rsquo;espace de la light. Pour cela, on suppose que l&rsquo;application fournie une matrice ViewProjection adaptée et le code est simplement le suivant:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-glsl" data-lang="glsl"><span style="color:#75715e">// directionalSM.vs.glsl</span><span style="">
</span><span style=""></span><span style="color:#75715e">#version 330</span><span style="">
</span><span style="">
</span><span style=""></span><span style="">layout</span><span style="">(</span><span style="">location</span><span style=""> </span><span style="color:#f92672">=</span><span style=""> </span><span style="color:#ae81ff">0</span><span style="">)</span><span style=""> </span><span style="color:#66d9ef">in</span><span style=""> </span><span style="color:#66d9ef">vec3</span><span style=""> </span><span style="">aPosition</span><span style="">;</span><span style="">
</span><span style=""></span><span style="color:#66d9ef">uniform</span><span style=""> </span><span style="">mat4</span><span style=""> </span><span style="">uDirLightViewProjMatrix</span><span style="">;</span><span style="">
</span><span style="">
</span><span style=""></span><span style="color:#66d9ef">void</span><span style=""> </span><span style="">main</span><span style="">()</span><span style="">
</span><span style=""></span><span style="">{</span><span style="">
</span><span style="">    </span><span style="">gl_Position</span><span style=""> </span><span style="color:#f92672">=</span><span style="">  </span><span style="">uDirLightViewProjMatrix</span><span style=""> </span><span style="color:#f92672">*</span><span style=""> </span><span style="color:#66d9ef">vec4</span><span style="">(</span><span style="">aPosition</span><span style="">,</span><span style=""> </span><span style="color:#ae81ff">1</span><span style="">);</span><span style="">
</span><span style=""></span><span style="">}</span></code></pre>
</div>
<p>Le fragment shader n&rsquo;a rien a faire car tout ce qui nous interesse c&rsquo;est la depth des fragments. Or la depth est directement écrite par la carte graphique dans le depth buffer après l&rsquo;execution du fragment shader. On se contente donc d&rsquo;écrire un fragment shader minimal qui ne sort que du noir:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-glsl" data-lang="glsl"><span style="color:#75715e">// directionalSM.fs.glsl</span><span style="">
</span><span style=""></span><span style="color:#75715e">#version 330</span><span style="">
</span><span style=""></span><span style="color:#66d9ef">out</span><span style=""> </span><span style="color:#66d9ef">vec3</span><span style=""> </span><span style="">fColor</span><span style="">;</span><span style="">
</span><span style=""></span><span style="color:#66d9ef">void</span><span style=""> </span><span style="">main</span><span style="">()</span><span style="">
</span><span style=""></span><span style="">{</span><span style="">
</span><span style="">    </span><span style="">fColor</span><span style=""> </span><span style="color:#f92672">=</span><span style=""> </span><span style="color:#66d9ef">vec3</span><span style="">(</span><span style="color:#ae81ff">0</span><span style="">);</span><span style="">
</span><span style=""></span><span style="">}</span></code></pre>
</div>
<p>Dans l&rsquo;application, ajoutez un nouveau programme et une variable pour stocker la location de l&rsquo;uniform <em>uDirLightViewProjMatrix</em>:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="">glmlv</span><span style="color:#f92672">::</span><span style="">GLProgram</span><span style=""> </span><span style="">m_directionalSMProgram</span><span style="">;</span><span style="">
</span><span style=""></span><span style="">GLint</span><span style=""> </span><span style="">m_uDirLightViewProjMatrix</span><span style="">;</span></code></pre>
</div>
<p>Dans le constructor, compilez le programme à partir des deux nouveaux shaders et récupérez à la location avec <em>glGetUniformLocation</em>.</p>

<h1 id="création-de-la-shadow-map">Création de la shadow map</h1>

<p>Il faut à présent calculer la shadow map dans la boucle de rendu. Attention: ce calcul necessite un rendu de la scène, qui peut être coûteux. Il faut donc faire attention à ne recalculer la shadow map que si la light change de direction, par exemple en utilisant un booléen. La structure générale de la méthode run() devient donc:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#66d9ef">int</span><span style=""> </span><span style="">Application</span><span style="color:#f92672">::</span><span style="">run</span><span style="">()</span><span style="">
</span><span style=""></span><span style="">{</span><span style="">
</span><span style="">    </span><span style="">[...]</span><span style="">
</span><span style="">    </span><span style="color:#66d9ef">bool</span><span style=""> </span><span style="">directionalSMDirty</span><span style=""> </span><span style="color:#f92672">=</span><span style=""> </span><span style="">true</span><span style="">;</span><span style="">
</span><span style="">
</span><span style="">    </span><span style="color:#75715e">// Loop until the user closes the window
</span><span style="color:#75715e"></span><span style="">    </span><span style="color:#66d9ef">for</span><span style=""> </span><span style="">(</span><span style="color:#66d9ef">auto</span><span style=""> </span><span style="">iterationCount</span><span style=""> </span><span style="color:#f92672">=</span><span style=""> </span><span style="color:#ae81ff">0u</span><span style="">;</span><span style=""> </span><span style="color:#f92672">!</span><span style="">m_GLFWHandle</span><span style="">.</span><span style="">shouldClose</span><span style="">();</span><span style=""> </span><span style="color:#f92672">++</span><span style="">iterationCount</span><span style="">)</span><span style="">
</span><span style="">    </span><span style="">{</span><span style="">
</span><span style="">        </span><span style="">[...]</span><span style="">
</span><span style="">        </span><span style="color:#66d9ef">if</span><span style=""> </span><span style="">(</span><span style="">directionalSMDirty</span><span style="">)</span><span style="">
</span><span style="">        </span><span style="">{</span><span style="">
</span><span style="">            </span><span style="color:#75715e">// Calcul de la shadow map (**)
</span><span style="color:#75715e"></span><span style="">            </span><span style="">[...]</span><span style="">
</span><span style="">
</span><span style="">            </span><span style="">directionalSMDirty</span><span style=""> </span><span style="color:#f92672">=</span><span style=""> </span><span style="">false</span><span style="">;</span><span style=""> </span><span style="color:#75715e">// Pas de calcul au prochain tour
</span><span style="color:#75715e"></span><span style="">        </span><span style="">}</span><span style="">
</span><span style="">
</span><span style="">        </span><span style="color:#75715e">// Rendu
</span><span style="color:#75715e"></span><span style="">        </span><span style="">[...]</span><span style="">
</span><span style="">
</span><span style="">        </span><span style="color:#75715e">// Pseudo code dans le dessin de la GUI:
</span><span style="color:#75715e"></span><span style="">        </span><span style="color:#66d9ef">if</span><span style=""> </span><span style="">(</span><span style="">directional_light_change</span><span style="">)</span><span style="">
</span><span style="">        </span><span style="">{</span><span style="">
</span><span style="">            </span><span style="">directionalSMDirty</span><span style=""> </span><span style="color:#f92672">=</span><span style=""> </span><span style="">true</span><span style="">;</span><span style=""> </span><span style="color:#75715e">// Il faut recalculer la shadow map
</span><span style="color:#75715e"></span><span style="">        </span><span style="">}</span><span style="">
</span><span style="">        </span><span style="">[...]</span><span style="">
</span><span style="">    </span><span style="">}</span><span style="">
</span><span style=""></span><span style="">}</span></code></pre>
</div>
<p>Mettez en place cette structure de code par dessus le code actuel de rendu du deferred.</p>

<p>A la suite du commentaire *// Calcul de la shadow map (*<em>)</em>, ajoutez le code suivant:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="">m_directionalSMProgram</span><span style="">.</span><span style="">use</span><span style="">();</span><span style="">
</span><span style="">
</span><span style=""></span><span style="">glBindFramebuffer</span><span style="">(</span><span style="">GL_DRAW_FRAMEBUFFER</span><span style="">,</span><span style=""> </span><span style="">m_directionalSMFBO</span><span style="">);</span><span style="">
</span><span style=""></span><span style="">glViewport</span><span style="">(</span><span style="color:#ae81ff">0</span><span style="">,</span><span style=""> </span><span style="color:#ae81ff">0</span><span style="">,</span><span style=""> </span><span style="">m_nDirectionalSMResolution</span><span style="">,</span><span style=""> </span><span style="">m_nDirectionalSMResolution</span><span style="">);</span><span style="">
</span><span style=""></span><span style="">glClear</span><span style="">(</span><span style="">GL_COLOR_BUFFER_BIT</span><span style=""> </span><span style="color:#f92672">|</span><span style=""> </span><span style="">GL_DEPTH_BUFFER_BIT</span><span style="">);</span><span style="">
</span><span style="">
</span><span style=""></span><span style="">glUniformMatrix4fv</span><span style="">(</span><span style="">m_uDirLightViewProjMatrix</span><span style="">,</span><span style=""> </span><span style="color:#ae81ff">1</span><span style="">,</span><span style=""> </span><span style="">GL_FALSE</span><span style="">,</span><span style=""> </span><span style="">glm</span><span style="color:#f92672">::</span><span style="">value_ptr</span><span style="">(</span><span style="">dirLightProjMatrix</span><span style=""> </span><span style="color:#f92672">*</span><span style=""> </span><span style="">dirLightViewMatrix</span><span style="">));</span><span style="">
</span><span style="">
</span><span style=""></span><span style="">glBindVertexArray</span><span style="">(</span><span style="">m_SceneVAO</span><span style="">);</span><span style="">
</span><span style="">
</span><span style=""></span><span style="color:#75715e">// We draw each shape by specifying how much indices it carries, and with an offset in the global index buffer
</span><span style="color:#75715e"></span><span style="color:#66d9ef">for</span><span style=""> </span><span style="">(</span><span style="color:#66d9ef">const</span><span style=""> </span><span style="color:#66d9ef">auto</span><span style=""> </span><span style="">shape</span><span style=""> </span><span style="">:</span><span style=""> </span><span style="">m_shapes</span><span style="">)</span><span style=""> </span><span style="">{</span><span style="">
</span><span style="">    </span><span style="">glDrawElements</span><span style="">(</span><span style="">GL_TRIANGLES</span><span style="">,</span><span style=""> </span><span style="">shape</span><span style="">.</span><span style="">indexCount</span><span style="">,</span><span style=""> </span><span style="">GL_UNSIGNED_INT</span><span style="">,</span><span style=""> </span><span style="">(</span><span style="color:#66d9ef">const</span><span style=""> </span><span style="">GLvoid</span><span style="color:#f92672">*</span><span style="">)(</span><span style="">shape</span><span style="">.</span><span style="">indexOffset</span><span style=""> </span><span style="color:#f92672">*</span><span style=""> </span><span style="color:#66d9ef">sizeof</span><span style="">(</span><span style="">GLuint</span><span style="">)));</span><span style="">
</span><span style=""></span><span style="">}</span><span style="">
</span><span style="">
</span><span style=""></span><span style="">glBindVertexArray</span><span style="">(</span><span style="color:#ae81ff">0</span><span style="">);</span><span style="">
</span><span style="">
</span><span style=""></span><span style="">glBindFramebuffer</span><span style="">(</span><span style="">GL_DRAW_FRAMEBUFFER</span><span style="">,</span><span style=""> </span><span style="color:#ae81ff">0</span><span style="">);</span></code></pre>
</div>
<p>Ce code met en place le programme pour dessiner la shadow map, bind le FBO sur lequel la shadow map est attachée, puis dessine la scène. Logiquement, après ce dessin, la texture m_directionalSMTexture (attachée à m_directionalSMFBO) doit contenir la shadow map.</p>

<p>Dans ce code, il vous manque le calcul des deux matrices dirLightProjMatrix et dirLightViewMatrix, qui est le suivant (à faire au début de la boucle de rendu car ces variables serviront aussi à la shading pass):</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#66d9ef">static</span><span style=""> </span><span style="color:#66d9ef">const</span><span style=""> </span><span style="color:#66d9ef">auto</span><span style=""> </span><span style="">computeDirectionVectorUp</span><span style=""> </span><span style="color:#f92672">=</span><span style=""> </span><span style="">[](</span><span style="color:#66d9ef">float</span><span style=""> </span><span style="">phiRadians</span><span style="">,</span><span style=""> </span><span style="color:#66d9ef">float</span><span style=""> </span><span style="">thetaRadians</span><span style="">)</span><span style="">
</span><span style=""></span><span style="">{</span><span style="">
</span><span style="">    </span><span style="color:#66d9ef">const</span><span style=""> </span><span style="color:#66d9ef">auto</span><span style=""> </span><span style="">cosPhi</span><span style=""> </span><span style="color:#f92672">=</span><span style=""> </span><span style="">glm</span><span style="color:#f92672">::</span><span style="">cos</span><span style="">(</span><span style="">phiRadians</span><span style="">);</span><span style="">
</span><span style="">    </span><span style="color:#66d9ef">const</span><span style=""> </span><span style="color:#66d9ef">auto</span><span style=""> </span><span style="">sinPhi</span><span style=""> </span><span style="color:#f92672">=</span><span style=""> </span><span style="">glm</span><span style="color:#f92672">::</span><span style="">sin</span><span style="">(</span><span style="">phiRadians</span><span style="">);</span><span style="">
</span><span style="">    </span><span style="color:#66d9ef">const</span><span style=""> </span><span style="color:#66d9ef">auto</span><span style=""> </span><span style="">cosTheta</span><span style=""> </span><span style="color:#f92672">=</span><span style=""> </span><span style="">glm</span><span style="color:#f92672">::</span><span style="">cos</span><span style="">(</span><span style="">thetaRadians</span><span style="">);</span><span style="">
</span><span style="">    </span><span style="color:#66d9ef">return</span><span style=""> </span><span style="color:#f92672">-</span><span style="">glm</span><span style="color:#f92672">::</span><span style="">normalize</span><span style="">(</span><span style="">glm</span><span style="color:#f92672">::</span><span style="">vec3</span><span style="">(</span><span style="">sinPhi</span><span style=""> </span><span style="color:#f92672">*</span><span style=""> </span><span style="">cosTheta</span><span style="">,</span><span style=""> </span><span style="color:#f92672">-</span><span style="">glm</span><span style="color:#f92672">::</span><span style="">sin</span><span style="">(</span><span style="">thetaRadians</span><span style="">),</span><span style=""> </span><span style="">cosPhi</span><span style=""> </span><span style="color:#f92672">*</span><span style=""> </span><span style="">cosTheta</span><span style="">));</span><span style="">
</span><span style=""></span><span style="">};</span><span style="">
</span><span style="">
</span><span style=""></span><span style="color:#66d9ef">const</span><span style=""> </span><span style="color:#66d9ef">auto</span><span style=""> </span><span style="">sceneCenter</span><span style=""> </span><span style="color:#f92672">=</span><span style=""> </span><span style="color:#ae81ff">0.5f</span><span style=""> </span><span style="color:#f92672">*</span><span style=""> </span><span style="">(</span><span style="">m_BBoxMin</span><span style=""> </span><span style="color:#f92672">+</span><span style=""> </span><span style="">m_BBoxMax</span><span style="">);</span><span style="">
</span><span style=""></span><span style="color:#66d9ef">const</span><span style=""> </span><span style="color:#66d9ef">float</span><span style=""> </span><span style="">sceneRadius</span><span style=""> </span><span style="color:#f92672">=</span><span style=""> </span><span style="">m_SceneSizeLength</span><span style=""> </span><span style="color:#f92672">*</span><span style=""> </span><span style="color:#ae81ff">0.5f</span><span style="">;</span><span style="">
</span><span style="">
</span><span style=""></span><span style="color:#66d9ef">const</span><span style=""> </span><span style="color:#66d9ef">auto</span><span style=""> </span><span style="">dirLightUpVector</span><span style=""> </span><span style="color:#f92672">=</span><span style=""> </span><span style="">computeDirectionVectorUp</span><span style="">(</span><span style="">glm</span><span style="color:#f92672">::</span><span style="">radians</span><span style="">(</span><span style="">m_DirLightPhiAngleDegrees</span><span style="">),</span><span style=""> </span><span style="">glm</span><span style="color:#f92672">::</span><span style="">radians</span><span style="">(</span><span style="">m_DirLightThetaAngleDegrees</span><span style="">));</span><span style="">
</span><span style=""></span><span style="color:#66d9ef">const</span><span style=""> </span><span style="color:#66d9ef">auto</span><span style=""> </span><span style="">dirLightViewMatrix</span><span style=""> </span><span style="color:#f92672">=</span><span style=""> </span><span style="">glm</span><span style="color:#f92672">::</span><span style="">lookAt</span><span style="">(</span><span style="">sceneCenter</span><span style=""> </span><span style="color:#f92672">+</span><span style=""> </span><span style="">m_DirLightDirection</span><span style=""> </span><span style="color:#f92672">*</span><span style=""> </span><span style="">sceneRadius</span><span style="">,</span><span style=""> </span><span style="">sceneCenter</span><span style="">,</span><span style=""> </span><span style="">dirLightUpVector</span><span style="">);</span><span style=""> </span><span style="color:#75715e">// Will not work if m_DirLightDirection is colinear to lightUpVector
</span><span style="color:#75715e"></span><span style="color:#66d9ef">const</span><span style=""> </span><span style="color:#66d9ef">auto</span><span style=""> </span><span style="">dirLightProjMatrix</span><span style=""> </span><span style="color:#f92672">=</span><span style=""> </span><span style="">glm</span><span style="color:#f92672">::</span><span style="">ortho</span><span style="">(</span><span style="color:#f92672">-</span><span style="">sceneRadius</span><span style="">,</span><span style=""> </span><span style="">sceneRadius</span><span style="">,</span><span style=""> </span><span style="color:#f92672">-</span><span style="">sceneRadius</span><span style="">,</span><span style=""> </span><span style="">sceneRadius</span><span style="">,</span><span style=""> </span><span style="color:#ae81ff">0.01f</span><span style=""> </span><span style="color:#f92672">*</span><span style=""> </span><span style="">sceneRadius</span><span style="">,</span><span style=""> </span><span style="color:#ae81ff">2.f</span><span style=""> </span><span style="color:#f92672">*</span><span style=""> </span><span style="">sceneRadius</span><span style="">);</span></code></pre>
</div>
<p>La matrice de projection du lumière directionelle est orthographique car une telle lumière voit &ldquo;en parallèle&rdquo; (tous les points sont illuminés selon la même direction). On fait en sorte que la light voit l&rsquo;ensemble de la scène en la plaçant au bord de la bounding sphere de la scène (d&rsquo;ou le calcul du centre et du rayon de la scène). Il vous sera peut être necessaire de stocker m_BBoxMin et m_BBoxMax si ce n&rsquo;est pas déjà fait, qui peuvent être obtenu au moment du chargement de la scène.</p>

<h1 id="utilisation-de-la-shadow-map">Utilisation de la shadow map</h1>

<p>Une fois la shadow map calculée, la shading pass peut l&rsquo;utiliser pour calculer la visibilité d&rsquo;un fragment pour la light concernée.</p>

<p>Il faut tout d&rsquo;abord modifier le fragment shader de la shading pass (shadingPass.fs.glsl) afin d&rsquo;utiliser la shadow map.
Ajoutez les uniform suivantes:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-glsl" data-lang="glsl"><span style="color:#66d9ef">uniform</span><span style=""> </span><span style="">mat4</span><span style=""> </span><span style="">uDirLightViewProjMatrix</span><span style="">;</span><span style="">
</span><span style=""></span><span style="color:#66d9ef">uniform</span><span style=""> </span><span style="color:#66d9ef">sampler2D</span><span style=""> </span><span style="">uDirLightShadowMap</span><span style="">;</span><span style="">
</span><span style=""></span><span style="color:#66d9ef">uniform</span><span style=""> </span><span style="color:#66d9ef">float</span><span style=""> </span><span style="">uDirLightShadowMapBias</span><span style="">;</span></code></pre>
</div>
<p>La matrice permet de passer les fragment vus par la caméra dans l&rsquo;espace projeté de la light. Une fois cette projection faite, on peut lire dans la shadow map pour obtenir la depth enregistrée dans le pixel concerné. Cette depth doit alors être comparée à la depth du fragment courant, toujours selon le point de vue de la light, pour savoir s&rsquo;il est visible depuis la light.</p>

<p>Le code est le suivant:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-glsl" data-lang="glsl"><span style="color:#66d9ef">vec4</span><span style=""> </span><span style="">positionInDirLightScreen</span><span style=""> </span><span style="color:#f92672">=</span><span style=""> </span><span style="">uDirLightViewProjMatrix</span><span style=""> </span><span style="color:#f92672">*</span><span style=""> </span><span style="color:#66d9ef">vec4</span><span style="">(</span><span style="">position</span><span style="">,</span><span style=""> </span><span style="color:#ae81ff">1</span><span style="">);</span><span style="">
</span><span style=""></span><span style="color:#66d9ef">vec3</span><span style=""> </span><span style="">positionInDirLightNDC</span><span style=""> </span><span style="color:#f92672">=</span><span style=""> </span><span style="color:#66d9ef">vec3</span><span style="">(</span><span style="">positionInDirLightScreen</span><span style=""> </span><span style="color:#f92672">/</span><span style=""> </span><span style="">positionInDirLightScreen</span><span style="">.</span><span style="">w</span><span style="">)</span><span style=""> </span><span style="color:#f92672">*</span><span style=""> </span><span style="color:#ae81ff">0.5</span><span style=""> </span><span style="color:#f92672">+</span><span style=""> </span><span style="color:#ae81ff">0.5</span><span style="">;</span><span style="">
</span><span style=""></span><span style="color:#66d9ef">float</span><span style=""> </span><span style="">depthBlockerInDirSpace</span><span style=""> </span><span style="color:#f92672">=</span><span style=""> </span><span style="">texture</span><span style="">(</span><span style="">uDirLightShadowMap</span><span style="">,</span><span style=""> </span><span style="">positionInDirLightNDC</span><span style="">.</span><span style="">xy</span><span style="">).</span><span style="">r</span><span style="">;</span><span style="">
</span><span style=""></span><span style="color:#66d9ef">float</span><span style=""> </span><span style="">dirLightVisibility</span><span style=""> </span><span style="color:#f92672">=</span><span style=""> </span><span style="">positionInDirLightNDC</span><span style="">.</span><span style="">z</span><span style=""> </span><span style="color:#f92672">&lt;</span><span style=""> </span><span style="">depthBlockerInDirSpace</span><span style=""> </span><span style="color:#f92672">+</span><span style=""> </span><span style="">uDirLightShadowMapBias</span><span style=""> </span><span style="color:#f92672">?</span><span style=""> </span><span style="color:#ae81ff">1.0</span><span style=""> </span><span style="color:#f92672">:</span><span style=""> </span><span style="color:#ae81ff">0.0</span><span style="">;</span></code></pre>
</div>
<p>La première ligne applique la matrice pour projeter la position du fragment courant.</p>

<p>La deuxième light homogénise cette position projetée en divisant par la coordonnée &ldquo;w&rdquo;. A l&rsquo;issue de cette opération, toutes les coordonnées sont entre -1 et 1. Afin de pouvoir lire dans la shadow map, on les ramène entre 0 et 1 grace au *0.5 + 0.5. Les coordonnées .xy identifie le pixel à lire dans la shadow map, et la coordonnée .z stocke la depth du fragment selon le point de vue de la light.</p>

<p>La troisème ligne lit la depth stockée dans la shadow map à la position du fragment.</p>

<p>Enfin la dernière ligne compare la depth stockée à la depth du fragment afin de savoir si la light est visible.</p>

<p>On rajoute un biais uDirLightShadowMapBias afin d&rsquo;éviter les erreurs d&rsquo;imprecision numériques qui apparaissent sous la forme de &ldquo;shadow acnée&rdquo; (mettez ce bias a 0 initialement pour voir le problème).</p>

<p>La variable dirLightVisibility vaut 0 si le fragment est occulté depuis la ligne, 1 sinon. Multipliez cette variable à la contribution de la lumière directionnelle afin de l&rsquo;ajouter dans fColor.</p>

<p>Une fois les modifications effectuées sur le shader, modifier le code de l&rsquo;application pour récupérer la location des nouvelles uniformes. Dans la boucle de rendu, settez ces uniforms correctement et bindez la texture de shadow map m_directionalSMTexture ainsi que le sampler m_directionalSMSampler sur une nouvelle texture unit (non utilisée par le GBuffer). Pour le uDirLightShadowMapBias, faites en sorte qu&rsquo;il soit controlable depuis la GUI.</p>

<p>Enfin il y a un piège pour la matrice uDirLightViewProjMatrix. Le code est un peu différent de la passe précédente puisqu&rsquo;il ne suffit de pas multiplier dirLightProjMatrix à dirLightViewMatrix pour obtenir cette matrice.</p>

<p>Cela est du au fait que les fragments de la shading pass ne sont pas en espace World mais en espace View de la caméra. Il faut donc qu&rsquo;ils soient repassés en World avant d&rsquo;être transformés dans l&rsquo;espace de la light. Pour cela, il suffit de multiplier à gauche par l&rsquo;inverse de la View matrix de la caméra:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#66d9ef">const</span><span style=""> </span><span style="color:#66d9ef">auto</span><span style=""> </span><span style="">rcpViewMatrix</span><span style=""> </span><span style="color:#f92672">=</span><span style=""> </span><span style="">m_viewController</span><span style="">.</span><span style="">getRcpViewMatrix</span><span style="">();</span><span style=""> </span><span style="color:#75715e">// Inverse de la view matrix de la caméra
</span><span style="color:#75715e"></span><span style="">glUniformMatrix4fv</span><span style="">(</span><span style="">m_uDirLightViewProjMatrix_shadingPass</span><span style="">,</span><span style=""> </span><span style="color:#ae81ff">1</span><span style="">,</span><span style=""> </span><span style="">GL_FALSE</span><span style="">,</span><span style=""> </span><span style="">glm</span><span style="color:#f92672">::</span><span style="">value_ptr</span><span style="">(</span><span style="">dirLightProjMatrix</span><span style=""> </span><span style="color:#f92672">*</span><span style=""> </span><span style="">dirLightViewMatrix</span><span style=""> </span><span style="color:#f92672">*</span><span style=""> </span><span style="">rcpViewMatrix</span><span style="">));</span></code></pre>
</div>
<h1 id="si-ça-ne-fonctionne-pas">Si ça ne fonctionne pas</h1>

<p>A ce stade, votre shadow mapping devrait fonctionner et vous devriez donc voir les ombres portées par les objets de la scène par rapport à la lumière directionnelle.</p>

<p>Néammoins, il peut exister une multitude de raisons pour lesquelles un shadow mapping ne fonctionnerait pas immédiatement (c&rsquo;est d&rsquo;ailleur rare qu&rsquo;il fonctionne du premier coup).</p>

<p>Afin de débogguer, une première approche peut être d&rsquo;afficher la depth map vue par la caméra. Malheureusement, la depth map ne peut pas être blittée à l&rsquo;ecran comme les autres textures du GBuffer.</p>

<p>Il faut donc coder un fragment shader dediée à l&rsquo;affichage de la depth map:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-glsl" data-lang="glsl"><span style="color:#75715e">// displayDepth.fs.glsl</span><span style="">
</span><span style=""></span><span style="color:#75715e">#version 330</span><span style="">
</span><span style="">
</span><span style=""></span><span style="color:#66d9ef">uniform</span><span style=""> </span><span style="color:#66d9ef">sampler2D</span><span style=""> </span><span style="">uGDepth</span><span style="">;</span><span style="">
</span><span style="">
</span><span style=""></span><span style="color:#66d9ef">out</span><span style=""> </span><span style="color:#66d9ef">vec3</span><span style=""> </span><span style="">fColor</span><span style="">;</span><span style="">
</span><span style="">
</span><span style=""></span><span style="color:#66d9ef">void</span><span style=""> </span><span style="">main</span><span style="">()</span><span style="">
</span><span style=""></span><span style="">{</span><span style="">
</span><span style="">    </span><span style="color:#66d9ef">float</span><span style=""> </span><span style="">depth</span><span style=""> </span><span style="color:#f92672">=</span><span style=""> </span><span style="">texelFetch</span><span style="">(</span><span style="">uGDepth</span><span style="">,</span><span style=""> </span><span style="color:#66d9ef">ivec2</span><span style="">(</span><span style="">gl_FragCoord</span><span style="">.</span><span style="">xy</span><span style="">),</span><span style=""> </span><span style="color:#ae81ff">0</span><span style="">).</span><span style="">r</span><span style="">;</span><span style="">
</span><span style="">    </span><span style="">fColor</span><span style=""> </span><span style="color:#f92672">=</span><span style=""> </span><span style="color:#66d9ef">vec3</span><span style="">(</span><span style="">depth</span><span style="">);</span><span style=""> </span><span style="color:#75715e">// Since the depth is between 0 and 1, pow it to darkness its value</span><span style="">
</span><span style=""></span><span style="">}</span></code></pre>
</div>
<p>Ce fragment shader peut être combiné à <em>shadingPass.vs.glsl</em> pour former un programme GLSL. En bindant correctment la depth map à afficher, et en dessinant un triangle sur tout l&rsquo;ecran, on peut ainsi afficher n&rsquo;importance quel depth map (en particulier celle représentant la shadow map de la light).</p>

<p>Voir sur la branche cheat pour un exemple.</p>

        </div>

        <div class="col side-menu side-menu-right page-content">
            <div class="toc-sidebar">
<nav id="TableOfContents">
<ul>
<li><a href="#initialisation">Initialisation</a></li>
<li><a href="#shaders">Shaders</a></li>
<li><a href="#création-de-la-shadow-map">Création de la shadow map</a></li>
<li><a href="#utilisation-de-la-shadow-map">Utilisation de la shadow map</a></li>
<li><a href="#si-ça-ne-fonctionne-pas">Si ça ne fonctionne pas</a></li>
</ul>
</nav>
</div>
        </div>
    </div>
</div>

</main>



<script src="https://code.jquery.com/jquery-3.2.1.slim.min.js" integrity="sha384-KJ3o2DKtIkvYIK3UENzmM7KCkRr/rE9/Qpg6aAZGJwFDMVNA/GpGFF93hXpG5KkN" crossorigin="anonymous"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/popper.js/1.12.9/umd/popper.min.js" integrity="sha384-ApNbgh9B+Y1QKtv3Rn7W3mgPxhU9K/ScQsAP7hUibX39j7fakFPskvXusvfa0b4Q" crossorigin="anonymous"></script>
<script src="https://maxcdn.bootstrapcdn.com/bootstrap/4.0.0-beta.3/js/bootstrap.min.js" integrity="sha384-a5N7Y/aK3qNeh15eJKGWxsqtnX/wWdSZSKp+81YjTmS15nvnvxKHuzaWwXHDli+4" crossorigin="anonymous"></script>

<script>
$(".toc-sidebar ul").addClass("nav flex-column");
$(".toc-sidebar li").addClass("nav-item");
$(".toc-sidebar a").addClass("nav-link");
</script>



</body>
</html>