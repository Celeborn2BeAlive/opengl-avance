

<!DOCTYPE html>
<html lang="fr">

<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
    <meta name="description" content="">
    <meta name="author" content="">
    <link rel="icon" href="../../../../favicon.ico">

    <title>Shading pass - OpenGL Avancé</title>

    
    <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/4.0.0-beta.3/css/bootstrap.min.css" integrity="sha384-Zug+QiDoJOrZ5t4lssLdxGhVrurbmBWopoEl+M6BdEfwnCJZtKxi1KgxUyJq13dy" crossorigin="anonymous">

    <style>
        body
        {
          font-family: "Work Sans", "Helvetica", "Tahoma", "Geneva", "Arial", sans-serif;
          color: #444444;
        }

        main
        {
          height:100vh;
          margin-top: 56px;;
        }

        h1, h2, h3, h4, h5, h6
        {
          margin: 2.5rem 0 1.5rem 0;
        }

        h1.section-title
        {
          font-family: "Novacento Sans Wide", "Helvetica", "Tahoma", "Geneva", "Arial", sans-serif;
          text-align: center;
          text-transform: uppercase;
          font-size: 3.25rem;
          margin: 1.0rem 0 1.5rem 0;
          font-weight: 200;
        }

        main a:hover
        {
          text-decoration: none;
        }

        main table
        {
          width: 100%;
          margin-bottom: 1rem;
        }

        main img
        {
          width: 100%;
        }

        .jumbotron
        {
          background-color: #EEEEEE;
        }

        .page-content
        {
          padding-top: 16px;
          padding-bottom: 1.5rem;
        }

        .main-article
        {
          margin-left: 15%;
          margin-right: 15%;
        }

        .middle-content
        {
          text-align: justify;
        }

        .side-menu
        {
          background-color: #EEEEEE;
          position: fixed;
          width: 15%;
          height: 100%;
          font-size: 1.0em;
          padding-left: 0px;
          padding-right: 0px;
        }

        .side-menu li li
        {
          font-size: 0.9em;
          width: 100%;
        }

        .side-menu a
        {
          color: #555555;
          font-weight: bold;
        }

        .side-menu a:hover
        {
          color: #CCCCCC;
          background-color: #343A40;
        }

        .side-menu-left
        {
          left: 0px;
        }

        .side-menu-right
        {
          right: 0px;
        }

        .highlight
        {
          margin-bottom: 1rem;
        }

        .highlight pre
        {
          margin: auto;
          padding: 1% 5% 1% 5%;
        }
    </style>
</head>

<body>

<nav class="navbar navbar-expand-md navbar-dark fixed-top bg-dark">
  <a class="navbar-brand" href="https://Celeborn2BeAlive.github.io/opengl-avance/">OpenGL Avancé</a>
  <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarsExampleDefault" aria-controls="navbarsExampleDefault" aria-expanded="false" aria-label="Toggle navigation">
    <span class="navbar-toggler-icon"></span>
  </button>

  <div class="collapse navbar-collapse" id="navbarsExampleDefault">
    <ul class="navbar-nav mr-auto">
        
            <li class="nav-item">
                <a class="nav-link" href="https://Celeborn2BeAlive.github.io/opengl-avance/01-introduction/introduction">Introduction</a>
            </li>
        
            <li class="nav-item">
                <a class="nav-link" href="https://Celeborn2BeAlive.github.io/opengl-avance/02-forward-renderer/pipeline">Forward Renderer</a>
            </li>
        
            <li class="nav-item active">
                <a class="nav-link" href="https://Celeborn2BeAlive.github.io/opengl-avance/03-deferred-renderer/pipeline">Deferred Renderer</a>
            </li>
        
            <li class="nav-item">
                <a class="nav-link" href="https://Celeborn2BeAlive.github.io/opengl-avance/04-shadow-mapping/introduction">Shadow Mapping</a>
            </li>
        
            <li class="nav-item">
                <a class="nav-link" href="https://Celeborn2BeAlive.github.io/opengl-avance/05-post-processing/introduction">Post Processing</a>
            </li>
        
            <li class="nav-item">
                <a class="nav-link" href="https://Celeborn2BeAlive.github.io/opengl-avance/06-course/opengl-context">Cours et Doc</a>
            </li>
        



      
    </ul>
  </div>
</nav>

<main role="main" class="main-article">

<div class="container-fluid">
    <div class="row">
        <div class="col side-menu side-menu-left page-content">
            <ul class="nav flex-column">
    
        <li class="nav-item">
            <a class="nav-link" href="https://Celeborn2BeAlive.github.io/opengl-avance/03-deferred-renderer/pipeline/">Pipeline de rendu</a>
        </li>
    
        <li class="nav-item">
            <a class="nav-link" href="https://Celeborn2BeAlive.github.io/opengl-avance/03-deferred-renderer/geometry-pass/">Geometry pass</a>
        </li>
    
        <li class="nav-item">
            <a class="nav-link" href="https://Celeborn2BeAlive.github.io/opengl-avance/03-deferred-renderer/shading-pass/">Shading pass</a>
        </li>
    
        <li class="nav-item">
            <a class="nav-link" href="https://Celeborn2BeAlive.github.io/opengl-avance/03-deferred-renderer/plus-loin/">Aller plus loin</a>
        </li>
    
</ul>
        </div>

        <div class="col middle-content page-content">
            <h1 class="section-title">Shading pass</h1>

            

<p>Il faut maintenant coder la shading pass, qui a pour role d&rsquo;illuminer chaque pixel en utilisant les textures du GBuffer qui viennents se substituer aux variables d&rsquo;entrées du fragment shader d&rsquo;un forward renderer.</p>

<h1 id="shaders">Shaders</h1>

<p>Créez deux nouveaux shaders <em>shadingPass.vs.glsl</em> et <em>shadingPass.fs.glsl</em>.</p>

<p>Le VS est destiner à traiter un simple quad en 2D couvrant tout l&rsquo;écran, tout ce passera dans le FS.
Voici donc le code du VS:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-glsl" data-lang="glsl"><span style="color:#75715e">#version 330</span><span style="">
</span><span style="">
</span><span style=""></span><span style="">layout</span><span style="">(</span><span style="">location</span><span style=""> </span><span style="color:#f92672">=</span><span style=""> </span><span style="color:#ae81ff">0</span><span style="">)</span><span style=""> </span><span style="color:#66d9ef">in</span><span style=""> </span><span style="color:#66d9ef">vec2</span><span style=""> </span><span style="">aPosition</span><span style="">;</span><span style="">
</span><span style="">
</span><span style=""></span><span style="color:#66d9ef">void</span><span style=""> </span><span style="">main</span><span style="">()</span><span style="">
</span><span style=""></span><span style="">{</span><span style="">
</span><span style="">    </span><span style="">gl_Position</span><span style=""> </span><span style="color:#f92672">=</span><span style="">  </span><span style="color:#66d9ef">vec4</span><span style="">(</span><span style="">aPosition</span><span style="">,</span><span style=""> </span><span style="color:#ae81ff">0</span><span style="">,</span><span style=""> </span><span style="color:#ae81ff">1</span><span style="">);</span><span style="">
</span><span style=""></span><span style="">}</span></code></pre>
</div>
<p>Pour le FS c&rsquo;est un peu plus compliqué, mais vous pouvez repartir de celui du forward renderer.
Il faut simplement remplacer les variables <em>in</em> et les lectures dans les textures de matériaux par des lectures dans les textures du GBuffer.</p>

<p>On ajoute donc les uniforms suivantes:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-glsl" data-lang="glsl"><span style="color:#66d9ef">uniform</span><span style=""> </span><span style="color:#66d9ef">sampler2D</span><span style=""> </span><span style="">uGPosition</span><span style="">;</span><span style="">
</span><span style=""></span><span style="color:#66d9ef">uniform</span><span style=""> </span><span style="color:#66d9ef">sampler2D</span><span style=""> </span><span style="">uGNormal</span><span style="">;</span><span style="">
</span><span style=""></span><span style="color:#66d9ef">uniform</span><span style=""> </span><span style="color:#66d9ef">sampler2D</span><span style=""> </span><span style="">uGAmbient</span><span style="">;</span><span style="">
</span><span style=""></span><span style="color:#66d9ef">uniform</span><span style=""> </span><span style="color:#66d9ef">sampler2D</span><span style=""> </span><span style="">uGDiffuse</span><span style="">;</span><span style="">
</span><span style=""></span><span style="color:#66d9ef">uniform</span><span style=""> </span><span style="color:#66d9ef">sampler2D</span><span style=""> </span><span style="">uGlossyShininess</span><span style="">;</span></code></pre>
</div>
<p>qu&rsquo;il faut utiliser dans le main du shader pour récupérer les infos géométrique du fragment et les infos de matériaux.
Pour lire dans les textures du GBuffer, il faut utiliser la fonction GLSL <em>texelFetch</em> ainsi que la variable built-in <em>gl_FragCoord</em> contenant les coordonnées du pixel courant. Exemple:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-glsl" data-lang="glsl"><span style="color:#66d9ef">vec3</span><span style=""> </span><span style="">position</span><span style=""> </span><span style="color:#f92672">=</span><span style=""> </span><span style="color:#66d9ef">vec3</span><span style="">(</span><span style="">texelFetch</span><span style="">(</span><span style="">uGPosition</span><span style="">,</span><span style=""> </span><span style="color:#66d9ef">ivec2</span><span style="">(</span><span style="">gl_FragCoord</span><span style="">.</span><span style="">xy</span><span style="">),</span><span style=""> </span><span style="color:#ae81ff">0</span><span style="">));</span><span style=""> </span><span style="color:#75715e">// Correspond a vViewSpacePosition dans le forward renderer</span></code></pre>
</div>
<p>Ensuite l&rsquo;algorithme pour calculer la couleur du fragment à partir des lights reste le meme.</p>

<p>Dans le code de l&rsquo;application, chargez et compilez vos deux shaders dans un second programme GLSL afin de vérifier que vous n&rsquo;avez pas fait d&rsquo;erreur de syntaxe. On utilisera ce nouveau programme par la suite dans la boucle de rendu.</p>

<p>A l&rsquo;initialisation, récupérez les locations des nouvelles uniformes (ainsi que des anciennes, mettez à jour le programme concerné puisqu&rsquo;on en a deux maintenant).</p>

<h1 id="un-quad-ou-un-triangle-voir-la-note">Un Quad (ou un triangle, voir la note)</h1>

<p>Afin de &ldquo;lancer&rdquo; la Shading Pass et pouvoir passer dans le fragment shader pour calculer la couleur de nos pixels, il faut un truc à dessiner à l&rsquo;écran. Puisque toute la géometrie visible depuis la caméra est déjà encodée dans le GBuffer, il suffira juste de dessiner un quad couvrant tout l&rsquo;écran pour pouvoir parcourir tous les pixels du GBuffer et faire notre traitement.</p>

<p>Dans la classe Application, ajoutez un nouveau VBO, IBO et VAO. Faite en sorte que ces trois objets stockent ce qu&rsquo;il faut pour dessiner un quad en 2D sur tout l&rsquo;ecran (de -1 à 1 sur chacun des axes). Il n&rsquo;y a que l&rsquo;attribut de position à envoyer.</p>

<div class="alert alert-note">
<p>Plutot que de dessiner un quad, qui comporte deux triangle, il est également possible de dessiner un triangle couvrant plus que tout les écrans. L&rsquo;ensemble des pixels du triangle en dehors de l&rsquo;écran seront discardés avant même d&rsquo;arriver dans le fragment shader.
Les coordonnées d&rsquo;un tel triangle peuvent etres les suivantes: (-1, -1), (3, -1), (-1, 3).
Dessinez le sur papier pour vous en convaincre.
Dans le cas d&rsquo;un triangle, pas besoin d&rsquo;IBO, on peut directement appeler <em>glDrawArrays</em>.</p>

</div>

<table>
<thead>
<tr>
<th>Sans DSA</th>
<th>DSA</th>
</tr>
</thead>

<tbody>
<tr>
<td>glGenBuffers</td>
<td>glCreateBuffers</td>
</tr>

<tr>
<td>glGenVertexArrays</td>
<td>glCreateVertexArrays</td>
</tr>

<tr>
<td>glBindBuffer(GL_ARRAY_BUFFER, vboID)</td>
<td></td>
</tr>

<tr>
<td>glBufferStorage</td>
<td>glNamedBufferStorage</td>
</tr>

<tr>
<td></td>
<td>glVertexArrayVertexBuffer</td>
</tr>

<tr>
<td></td>
<td>glVertexArrayAttribBinding</td>
</tr>

<tr>
<td>glEnableVertexAttribArray</td>
<td>glEnableVertexArrayAttrib</td>
</tr>

<tr>
<td>glVertexAttribPointer</td>
<td>glVertexArrayAttribFormat</td>
</tr>

<tr>
<td>glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, vboID)</td>
<td>glVertexArrayElementBuffer</td>
</tr>
</tbody>
</table>

<h1 id="au-rendu">Au Rendu</h1>

<p>Dans la boucle de rendu, remplacez le blit des textures du GBuffer de l&rsquo;exercice précédent par les étapes suivantes:</p>

<ul>
<li><em>.use()</em> sur le programme de la shading pass</li>
<li>set des uniforms de light (point light et directional light, qui sont normalement dans le fragment shader de la shading pass)</li>
<li>binding des textures du GBuffer sur différentes texture units (de 0 à 4 inclut)</li>
<li>set des uniforms correspondant aux textures du GBuffer (chacune avec l&rsquo;indice de la texture unit sur laquelle la texture correspondante est bindée)</li>
<li>dessin du quad/triangle</li>
</ul>

<p>Fonctions OpenGL à utiliser au rendu:</p>

<ul>
<li>glUniform3fv, glUniform1i</li>
<li>glActiveTexture</li>
<li>glBindTexture</li>
<li>glBindVertexArray</li>
<li>glDrawElements (ou glDrawArrays si triangle)</li>
<li>glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT)</li>
</ul>

<p>Après ça vous devriez retrouver le rendu que vous aviez avec le forward renderer.</p>

<p>Vous pouvez essayer de charger de grosse scènes (ou génération aléatoire de plein de géométrie) pour comparer les performances des deux méthodes de rendu.</p>

        </div>

        <div class="col side-menu side-menu-right page-content">
            <div class="toc-sidebar">
<nav id="TableOfContents">
<ul>
<li><a href="#shaders">Shaders</a></li>
<li><a href="#un-quad-ou-un-triangle-voir-la-note">Un Quad (ou un triangle, voir la note)</a></li>
<li><a href="#au-rendu">Au Rendu</a></li>
</ul>
</nav>
</div>
        </div>
    </div>
</div>

</main>



<script src="https://code.jquery.com/jquery-3.2.1.slim.min.js" integrity="sha384-KJ3o2DKtIkvYIK3UENzmM7KCkRr/rE9/Qpg6aAZGJwFDMVNA/GpGFF93hXpG5KkN" crossorigin="anonymous"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/popper.js/1.12.9/umd/popper.min.js" integrity="sha384-ApNbgh9B+Y1QKtv3Rn7W3mgPxhU9K/ScQsAP7hUibX39j7fakFPskvXusvfa0b4Q" crossorigin="anonymous"></script>
<script src="https://maxcdn.bootstrapcdn.com/bootstrap/4.0.0-beta.3/js/bootstrap.min.js" integrity="sha384-a5N7Y/aK3qNeh15eJKGWxsqtnX/wWdSZSKp+81YjTmS15nvnvxKHuzaWwXHDli+4" crossorigin="anonymous"></script>

<script>
$(".toc-sidebar ul").addClass("nav flex-column");
$(".toc-sidebar li").addClass("nav-item");
$(".toc-sidebar a").addClass("nav-link");
</script>



</body>
</html>